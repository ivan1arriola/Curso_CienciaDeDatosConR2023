ggplot2::scale_y_continuous(
name = "Cantidad de Vacunados"
) +
ggplot2::scale_fill_discrete(
name = "Laboratorio",
labels = c("Sinovac + Astrazeneca", "Pfizer")
) +
ggplot2::theme(
legend.position="bottom"
)
# Chunk 13
library(here)
dir <- here()
# Chunk 14
indicador <- "NY.GDP.PCAP.PP.KD"
query <- list(
indicador = indicador,
url = paste0(
"https://api.worldbank.org/v2/es/indicator/",
indicador,
"?downloadformat=excel"
),
destfile = here(
dir,
paste0(
indicador,
".xls"
)
),
method = "curl"
)
if (!file.exists(query$destfile)) {
do.call(
download.file,
args = query
)
}
# Chunk 15
datos_banco <- readxl::read_excel("NY.GDP.PCAP.PP.KD.xls", col_names = TRUE,
sheet = "Data", range = readxl::cell_limits(c(4, NA), c(NA, 66)))
# Chunk 16
(
datos_banco2 <- clean_names(datos_banco)
)
# Chunk 17
(
datos_banco3 <- datos_banco2 %>%
tidyr::pivot_longer (
cols = 5:66,
names_to = "Año"
)
)
# Chunk 18
(
datos_banco4 <- datos_banco3 %>%
dplyr::filter(
country_code %in% c("ARG","CHL", "PRY", "URY")
)
)
# Chunk 19
reemplazarNAconNext <- function(values) {
indices_na <- which(is.na(values))
if (length(indices_na) == length(values)) {
values <- rep("SIN DATOS", length(values))
} else {
for (i in indices_na) {
siguiente_indice_no_na <- min(which(!is.na(values[(i+1):length(values)]))) + i
values[i] <- values[siguiente_indice_no_na]
}
}
return(values)
}
(
datos_banco5 <-
datos_banco4 %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNAconNext(value)
) %>%
dplyr::ungroup()
)
# Chunk 20
datos_banco5  %>%  dplyr::filter(Año > 2000) %>%
ggplot2::ggplot() +
ggplot2::geom_line(
ggplot2::aes(
x = as.Date(Año, format("%Y")),
y = value,
color = country_code
)
) +
ggplot2::scale_x_date( name = "Año") +
ggplot2::scale_y_continuous(name = "PIB per Capita a PPA") +
ggplot2::scale_color_discrete(name = "Pais") +
ggplot2::theme(
legend.position = "bottom",
legend.title = ggplot2::element_text(size = 13)
)
# Chunk 21
make_query <- function(indicador){
query <- list(
indicador = indicador,
url = paste0(
"https://api.worldbank.org/v2/es/indicator/",
indicador,
"?downloadformat=excel"
),
destfile = here(
dir,
paste0(
indicador,
".xls"
)
),
method = "curl"
)
return(query)
}
# Chunk 22
download_file <- function(query){
if (!file.exists(query$destfile)) {
do.call(
download.file,
args = query
)
}
}
# Chunk 23
load_file <- function(filename, sheet_name, range) {
datos_banco <- readxl::read_excel(filename, col_names = TRUE,
sheet = sheet_name, range = range)
return(datos_banco)
}
# Chunk 24
imputar_valores_faltantes <- function(df){
df <-
df %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNAconNext(value)
) %>%
dplyr::ungroup()
}
tidy_data <- function(df){
df<-  df %>% clean_names() %>%
tidyr::pivot_longer (
cols = 5:66,
names_to = "Año"
) %>% imputar_valores_faltantes()
return(df)
}
# Chunk 25
filter_country <- function(df, countries){
if(countries=="all") return(df)
df <- df %>%
dplyr::filter(
country_name %in% countries
)
return(df)
}
tidy_wdi <- function(
country = "all",
indicador,
destfolder = here::here(
"Tarea_3",
"data"
),
sheet_name = "REVISAR",
range = "REVISAR"
) {
# Generar la consulta al Banco mundial. Necesitamos:
# El nombre del indicador como argumento y la función debe
# contener devolver la MISMA lista del ejercicio 1.
# Por temas de compatibilidad, utilice el método curl e
# interpole con el indicador la misma url del ejercicio anterior.
# Es decir, el Banco Mundial sigue el siguiente patrón:
# https://api.worldbank.org/v2/es/indicator/{Indicador}?downloadformat=excel
query <- make_query(
indicador = indicador
)
# Incorporar la lógica de la descarga del archivo.
# En el caso de existir el archivo NO se debe de descargar.
download_file(
query = query
)
# Carga de los archivos en formato "sucio"
df <- load_file(
filename = query$destfile,
sheet_name = sheet_name,
range = range
)
# Limpieza de datos:
# Incluir la limpieza de los nombres del data.frame
# (crear una función clean_names(df)
# puede ser una buena idea)
# Convertir el archivo siguiendo
# el concepto de Tidy Data
# Imputación de datos faltantes (
# crear una función imputar_valores_faltantes()
# ) puede ser una buena idea
df <- tidy_data(df)
# En el caso que se quiera filtrar países
# (el argumento country debe ser distinto de 'all')
# filtrar el data.frame
df <- df  %>%
filter_country(
country
)
return(df)
}
prueba <- tidy_wdi(indicador = indicador, sheet_name = "Data", range = readxl::cell_limits(c(4, NA), c(NA, 66)) )
reemplazarNAconNext <- function(values) {
indices_na <- which(is.na(values))
for (i in indices_na) {
siguiente_indice_no_na <- min(which(!is.na(values[(i+1):length(values)]))) + i
values[i] <- values[siguiente_indice_no_na]
}
return(values)
}
(
datos_banco5 <-
datos_banco4 %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNAconNext(value)
) %>%
dplyr::ungroup()
)
reemplazarNA <- function(values) {
indices_na <- which(is.na(values))
for (i in indices_na) {
siguiente_indice_no_na <- min(which(!is.na(values[(i+1):length(values)]))) + i
values[i] <- values[siguiente_indice_no_na]
}
return(values)
}
imputar_valores_faltantes <- function(df){
df <-
df %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNA(value)
) %>%
dplyr::ungroup()
}
tidy_data <- function(df){
df<-  df %>% clean_names() %>%
tidyr::pivot_longer (
cols = 5:66,
names_to = "Año"
) %>% imputar_valores_faltantes()
return(df)
}
tidy_wdi <- function(
country = "all",
indicador,
destfolder = here::here(
"Tarea_3",
"data"
),
sheet_name = "REVISAR",
range = "REVISAR"
) {
# Generar la consulta al Banco mundial. Necesitamos:
# El nombre del indicador como argumento y la función debe
# contener devolver la MISMA lista del ejercicio 1.
# Por temas de compatibilidad, utilice el método curl e
# interpole con el indicador la misma url del ejercicio anterior.
# Es decir, el Banco Mundial sigue el siguiente patrón:
# https://api.worldbank.org/v2/es/indicator/{Indicador}?downloadformat=excel
query <- make_query(
indicador = indicador
)
# Incorporar la lógica de la descarga del archivo.
# En el caso de existir el archivo NO se debe de descargar.
download_file(
query = query
)
# Carga de los archivos en formato "sucio"
df <- load_file(
filename = query$destfile,
sheet_name = sheet_name,
range = range
)
# Limpieza de datos:
# Incluir la limpieza de los nombres del data.frame
# (crear una función clean_names(df)
# puede ser una buena idea)
# Convertir el archivo siguiendo
# el concepto de Tidy Data
# Imputación de datos faltantes (
# crear una función imputar_valores_faltantes()
# ) puede ser una buena idea
df <- tidy_data(df)
# En el caso que se quiera filtrar países
# (el argumento country debe ser distinto de 'all')
# filtrar el data.frame
df <- df  %>%
filter_country(
country
)
return(df)
}
prueba <- tidy_wdi(indicador = indicador, sheet_name = "Data", range = readxl::cell_limits(c(4, NA), c(NA, 66)) )
?tryCatch
reemplazarNA <- function(values) {
indices_na <- which(is.na(values))
for (i in indices_na) {
siguiente_indice_no_na <- tryCatch(
{
siguiente_indice_no_na <- min(which(!is.na(values[(i+1):length(values)]))) + i
return(siguiente_indice_no_na)
},
error = function(err){
return("Sin_Dato")
}
)
values[i] <- values[siguiente_indice_no_na]
}
return(values)
}
imputar_valores_faltantes <- function(df){
df <-
df %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNA(value)
) %>%
dplyr::ungroup()
}
tidy_data <- function(df){
df<-  df %>% clean_names() %>%
tidyr::pivot_longer (
cols = 5:66,
names_to = "Año"
) %>% imputar_valores_faltantes()
return(df)
}
tidy_wdi <- function(
country = "all",
indicador,
destfolder = here::here(
"Tarea_3",
"data"
),
sheet_name = "REVISAR",
range = "REVISAR"
) {
# Generar la consulta al Banco mundial. Necesitamos:
# El nombre del indicador como argumento y la función debe
# contener devolver la MISMA lista del ejercicio 1.
# Por temas de compatibilidad, utilice el método curl e
# interpole con el indicador la misma url del ejercicio anterior.
# Es decir, el Banco Mundial sigue el siguiente patrón:
# https://api.worldbank.org/v2/es/indicator/{Indicador}?downloadformat=excel
query <- make_query(
indicador = indicador
)
# Incorporar la lógica de la descarga del archivo.
# En el caso de existir el archivo NO se debe de descargar.
download_file(
query = query
)
# Carga de los archivos en formato "sucio"
df <- load_file(
filename = query$destfile,
sheet_name = sheet_name,
range = range
)
# Limpieza de datos:
# Incluir la limpieza de los nombres del data.frame
# (crear una función clean_names(df)
# puede ser una buena idea)
# Convertir el archivo siguiendo
# el concepto de Tidy Data
# Imputación de datos faltantes (
# crear una función imputar_valores_faltantes()
# ) puede ser una buena idea
df <- tidy_data(df)
# En el caso que se quiera filtrar países
# (el argumento country debe ser distinto de 'all')
# filtrar el data.frame
df <- df  %>%
filter_country(
country
)
return(df)
}
prueba <- tidy_wdi(indicador = indicador, sheet_name = "Data", range = readxl::cell_limits(c(4, NA), c(NA, 66)) )
reemplazarNA <- function(values) {
indices_na <- which(is.na(values))
for (i in indices_na) {
siguiente_indice_no_na <- tryCatch(
{
siguiente_indice_no_na <- min(which(!is.na(values[(i+1):length(values)]))) + i
return(siguiente_indice_no_na)
},
error = function(err){
return("Sin_Dato")
},
finally = {
print("ERROR")
}
)
values[i] <- values[siguiente_indice_no_na]
}
return(values)
}
imputar_valores_faltantes <- function(df){
df <-
df %>%
dplyr::group_by(country_code) %>%
dplyr::mutate(
country_name = ifelse(is.na(country_name), "SIN_DATO", country_name ),
country_code = ifelse(is.na(country_code), "SIN_DATO", country_code ),
indicator_name = ifelse(is.na(indicator_name), "SIN_DATO", indicator_name ),
indicator_code = ifelse(is.na(indicator_code), "SIN_DATO", indicator_code ),
Año = ifelse(is.na(Año), "SIN_DATO", Año ),
valor_imputado = ifelse(is.na(value), 1, 0 ),
value = reemplazarNA(value)
) %>%
dplyr::ungroup()
}
tidy_data <- function(df){
df<-  df %>% clean_names() %>%
tidyr::pivot_longer (
cols = 5:66,
names_to = "Año"
) %>% imputar_valores_faltantes()
return(df)
}
tidy_wdi <- function(
country = "all",
indicador,
destfolder = here::here(
"Tarea_3",
"data"
),
sheet_name = "REVISAR",
range = "REVISAR"
) {
# Generar la consulta al Banco mundial. Necesitamos:
# El nombre del indicador como argumento y la función debe
# contener devolver la MISMA lista del ejercicio 1.
# Por temas de compatibilidad, utilice el método curl e
# interpole con el indicador la misma url del ejercicio anterior.
# Es decir, el Banco Mundial sigue el siguiente patrón:
# https://api.worldbank.org/v2/es/indicator/{Indicador}?downloadformat=excel
query <- make_query(
indicador = indicador
)
# Incorporar la lógica de la descarga del archivo.
# En el caso de existir el archivo NO se debe de descargar.
download_file(
query = query
)
# Carga de los archivos en formato "sucio"
df <- load_file(
filename = query$destfile,
sheet_name = sheet_name,
range = range
)
# Limpieza de datos:
# Incluir la limpieza de los nombres del data.frame
# (crear una función clean_names(df)
# puede ser una buena idea)
# Convertir el archivo siguiendo
# el concepto de Tidy Data
# Imputación de datos faltantes (
# crear una función imputar_valores_faltantes()
# ) puede ser una buena idea
df <- tidy_data(df)
# En el caso que se quiera filtrar países
# (el argumento country debe ser distinto de 'all')
# filtrar el data.frame
df <- df  %>%
filter_country(
country
)
return(df)
}
prueba <- tidy_wdi(indicador = indicador, sheet_name = "Data", range = readxl::cell_limits(c(4, NA), c(NA, 66)) )
